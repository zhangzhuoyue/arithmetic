给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
链接：https://leetcode-cn.com/problems/remove-element

分析：
利用双指针法，慢指针i，快指针j。如果快指针的元素和val不相同，则nums[i] = nums[j]将快指针的值覆盖慢指针的值。
如果快指针的值=val值，则将这个相同的值跳过。知道有不相同的元素出现。最后数组剩下的数据就是除掉指定元素。




方法一：双指针
思路

既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关



该解法与 删除排序数组中的重复项 的解法十分相似。

public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

时间复杂度：O(n)，
假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。

空间复杂度：O(1)。


方法二：
双指针--当要删除的数据很少的时

思路
现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。
另一个例子是 num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5] 这几个元素左移一步，因为问题描述中提
到元素的顺序可以更改。

算法
当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。
请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。

public int removeElement(int[] nums, int val) {
    int i = 0;
    int n = nums.length;
    while (i < n) {
        if (nums[i] == val) {
            nums[i] = nums[n - 1];
            // reduce array size by one
            n--;
        } else {
            i++;
        }
    }
    return n;
}
时间复杂度：O(n)
空间复杂度：O(1)


拓展：
如果需要将数组中重复的个数都找出来。将上面的不变性条件修改。




